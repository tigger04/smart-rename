#!/usr/bin/env bash
# ABOUTME: Smart file renaming using AI to generate descriptive filenames
# ABOUTME: Simple, focused implementation that actually works

set -euo pipefail

VERSION="4.0.0"
SCRIPT_NAME="smart-rename"
CONFIG_DIR="$HOME/.config/smart-rename"
CONFIG_FILE="$CONFIG_DIR/config.yaml"

# Configuration variables with defaults
PROMPT_TEMPLATE=""
BASE_CURRENCY="EUR"
OLLAMA_MODEL="mistral"
OPENAI_MODEL="gpt-4o-mini"
CLAUDE_MODEL="claude-3-haiku-20240307"
MAX_CONTENT_LENGTH=5000
API_TIMEOUT=30

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]] && command -v yq >/dev/null 2>&1; then
        # Load prompt template
        local prompt=$(yq eval '.prompt.template // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$prompt" ]] && PROMPT_TEMPLATE="$prompt"

        # Load currency
        local currency=$(yq eval '.currency.base // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$currency" ]] && BASE_CURRENCY="$currency"

        # Load API settings
        local ollama_model=$(yq eval '.api.ollama.model // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$ollama_model" ]] && OLLAMA_MODEL="$ollama_model"

        local openai_model=$(yq eval '.api.openai.model // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$openai_model" ]] && OPENAI_MODEL="$openai_model"

        local claude_model=$(yq eval '.api.claude.model // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$claude_model" ]] && CLAUDE_MODEL="$claude_model"

        # Load API keys if present
        local openai_key=$(yq eval '.api.openai.key // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$openai_key" ]] && export OPENAI_API_KEY="$openai_key"

        local claude_key=$(yq eval '.api.claude.key // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$claude_key" ]] && export CLAUDE_API_KEY="$claude_key"

        # Load processing settings
        local max_len=$(yq eval '.processing.max_content_length // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$max_len" ]] && MAX_CONTENT_LENGTH="$max_len"

        local timeout=$(yq eval '.api.ollama.timeout // ""' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$timeout" ]] && API_TIMEOUT="$timeout"
    fi

    # Set default prompt if not configured
    if [[ -z "$PROMPT_TEMPLATE" ]]; then
        PROMPT_TEMPLATE="Generate a concise, descriptive filename for the following content (no extension, lowercase, use hyphens). For receipts/invoices use YYYY-MM-DD-amount-description format with $BASE_CURRENCY as default currency. Content: {{CONTENT}}"
    fi
}

# Simple function to process a file
process_file() {
    local file="$1"
    local content=""

    # Read file content based on type
    local extension="${file##*.}"
    extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')

    case "$extension" in
        pdf)
            # Try to extract text from PDF
            if command -v pdftotext >/dev/null 2>&1; then
                content=$(pdftotext "$file" - 2>/dev/null | head -c "$MAX_CONTENT_LENGTH") || {
                    echo "Error extracting text from PDF: $file" >&2
                    echo "Hint: Install poppler-utils for PDF support (brew install poppler)" >&2
                    return 1
                }
            else
                echo "Error: pdftotext not found. Install poppler-utils for PDF support:" >&2
                echo "  brew install poppler" >&2
                return 1
            fi
            ;;
        jpg|jpeg|png|gif|bmp|tiff|webp)
            # For images, we'd need vision API support
            echo "Image files require AI with vision support (not yet implemented)" >&2
            return 1
            ;;
        *)
            # Plain text files
            content=$(head -c "$MAX_CONTENT_LENGTH" "$file" 2>/dev/null) || {
                echo "Error reading file: $file" >&2
                return 1
            }
            ;;
    esac

    if [[ -z "$content" ]]; then
        echo "File is empty: $file" >&2
        return 1
    fi

    # Build prompt from template
    local prompt="$PROMPT_TEMPLATE"
    prompt="${prompt//\{\{CONTENT\}\}/$content}"
    prompt="${prompt//\{\{FILENAME\}\}/$file}"
    prompt="${prompt//\{\{BASE_CURRENCY\}\}/$BASE_CURRENCY}"

    # Try to get AI response
    local new_name=""

    # Try Ollama if available
    if command -v ollama >/dev/null 2>&1; then
        echo "Using Ollama ($OLLAMA_MODEL)..." >&2
        new_name=$(echo "$prompt" | timeout "$API_TIMEOUT" ollama run "$OLLAMA_MODEL" 2>/dev/null | head -1) || true
    fi

    # Try OpenAI if we have a key and no response yet
    if [[ -z "$new_name" && -n "${OPENAI_API_KEY:-}" ]]; then
        echo "Using OpenAI ($OPENAI_MODEL)..." >&2
        local json_payload=$(jq -n --arg p "$prompt" --arg m "$OPENAI_MODEL" '{
            model: $m,
            messages: [{role: "user", content: $p}],
            max_tokens: 100
        }')

        new_name=$(curl -s --max-time "$API_TIMEOUT" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$json_payload" | jq -r '.choices[0].message.content // empty' | head -1) || true
    fi

    # Try Claude if we have a key and no response yet
    if [[ -z "$new_name" && -n "${CLAUDE_API_KEY:-}" ]]; then
        echo "Using Claude ($CLAUDE_MODEL)..." >&2
        local json_payload=$(jq -n --arg p "$prompt" --arg m "$CLAUDE_MODEL" '{
            model: $m,
            messages: [{role: "user", content: $p}],
            max_tokens: 100
        }')

        new_name=$(curl -s --max-time "$API_TIMEOUT" https://api.anthropic.com/v1/messages \
            -H "x-api-key: $CLAUDE_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d "$json_payload" | jq -r '.content[0].text // empty' | head -1) || true
    fi

    if [[ -z "$new_name" ]]; then
        echo "Error: Could not generate filename (no AI service available)" >&2
        return 1
    fi

    # Clean the name
    new_name=$(echo "$new_name" | tr -d '"' | tr ' ' '-' | tr -cd '[:alnum:]-' | tr '[:upper:]' '[:lower:]')

    # Add extension
    local ext="${file##*.}"
    if [[ "$ext" != "$file" ]]; then
        new_name="${new_name}.${ext}"
    fi

    echo "Generated name: $new_name" >&2

    # Check if file exists
    if [[ -e "$new_name" ]]; then
        echo "File already exists: $new_name" >&2
        return 1
    fi

    # Confirm rename unless auto mode
    if [[ "$AUTO_RENAME" != "true" ]]; then
        read -p "Rename '$file' to '$new_name'? (y/N): " -r
        if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
            echo "Skipped"
            return 0
        fi
    fi

    # Rename the file
    mv "$file" "$new_name" && echo "Renamed: $file -> $new_name"
}

# Show help
show_help() {
    cat <<EOF
USAGE: $SCRIPT_NAME [OPTIONS] PATTERN [PATTERN...]

DESCRIPTION:
  AI-powered file renaming tool that generates intelligent filenames

OPTIONS:
  -h, --help        Show this help message
  -v, --version     Show version
  -y, --yes         Auto-rename without confirmation
  -r, --recursive   Search recursively
  -g, --glob        Use glob pattern instead of regex

EXAMPLES:
  $SCRIPT_NAME 'scan.*\.pdf'        # Find files matching regex
  $SCRIPT_NAME -g '*.txt'            # Find files matching glob
  $SCRIPT_NAME -r 'invoice'          # Recursive search
  $SCRIPT_NAME -y document.pdf       # Specific file, auto-rename

EOF
}

# Main
if [[ $# -eq 0 ]]; then
    show_help
    exit 1
fi

# Parse arguments
AUTO_RENAME=false
RECURSIVE=false
USE_GLOB=false
PATTERNS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "$SCRIPT_NAME $VERSION"
            exit 0
            ;;
        -y|--yes)
            AUTO_RENAME=true
            shift
            ;;
        -r|--recursive)
            RECURSIVE=true
            shift
            ;;
        -g|--glob)
            USE_GLOB=true
            shift
            ;;
        *)
            PATTERNS+=("$1")
            shift
            ;;
    esac
done

if [[ ${#PATTERNS[@]} -eq 0 ]]; then
    echo "Error: No pattern specified"
    show_help
    exit 1
fi

# Load configuration
load_config

# Process all patterns
for PATTERN in "${PATTERNS[@]}"; do
    # Check if pattern is a file
    if [[ -f "$PATTERN" ]]; then
        # Single file mode
        if [[ "$AUTO_RENAME" != "true" ]]; then
            read -p "Process '$PATTERN'? (y/N): " -r
            if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
                echo "Skipped: $PATTERN" >&2
                continue
            fi
        fi
        process_file "$PATTERN"
    else
        # Pattern matching mode - find files
        echo "Searching for files matching: $PATTERN" >&2

        # Build fd arguments
        FD_ARGS=()

        # Add depth control
        if [[ "$RECURSIVE" == "false" ]]; then
            FD_ARGS+=(--max-depth 1)
        fi

        # Add pattern based on mode
        if [[ "$USE_GLOB" == "true" ]]; then
            FD_ARGS+=(--glob "$PATTERN")
        else
            # Default is regex
            FD_ARGS+=("$PATTERN")
        fi

        FD_ARGS+=(--type f .)

        # Use fd to find files
        mapfile -t files < <(fd "${FD_ARGS[@]}" 2>/dev/null || true)

        if [[ ${#files[@]} -eq 0 ]]; then
            echo "No files found matching pattern: $PATTERN" >&2
            continue
        fi

        echo "Found ${#files[@]} files:" >&2
        for file in "${files[@]}"; do
            echo "  - $file" >&2
        done
        echo "" >&2

        # Process each file
        for file in "${files[@]}"; do
            if [[ "$AUTO_RENAME" != "true" ]]; then
                read -p "Process '$file'? (y/N): " -r
                if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
                    echo "Skipped: $file" >&2
                    continue
                fi
            fi

            process_file "$file" || true
            echo "" >&2
        done
    fi
done